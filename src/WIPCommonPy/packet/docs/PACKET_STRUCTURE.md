# WIP パケット構造仕様

Weather Transmission Protocol (WIP) のパケット構造に関する詳細な技術仕様書です。

## 📊 パケット全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           WIPパケット構造                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  🔹 基本フィールド（固定128ビット）                                          │
│  ┌─────┬─────────┬──────┬─────────────────┬──────────┬──────────┐        │
│  │ 制御│ パケット │タイプ│   フラグ群      │タイムスタンプ│エリア情報│        │
│  │ 情報│   情報  │ 情報 │   (6種類)       │  (64bit)  │ (32bit)  │        │
│  └─────┴─────────┴──────┴─────────────────┴──────────┴──────────┘        │
│   0-7   8-18     19-21    22-31           32-95      96-127               │
│                                                                             │
│  🔸 拡張フィールド（可変長、ex_flag=1の場合のみ）                           │
│  ┌────────────────┬────────────────┬────────────────┬─────────────┐      │
│  │   レコード1    │   レコード2    │   レコード3    │     ...     │      │
│  │ ┌───┬────────┐ │ ┌───┬────────┐ │ ┌───┬────────┐ │             │      │
│  │ │ヘッダ│データ│ │ │ヘッダ│データ│ │ │ヘッダ│データ│ │             │      │
│  │ │16bit│可変長│ │ │16bit│可変長│ │ │16bit│可変長│ │             │      │
│  │ └───┴────────┘ │ └───┴────────┘ │ └───┴────────┘ │             │      │
│  └────────────────┴────────────────┴────────────────┴─────────────┘      │
│   128+              144+              160+                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 🔹 基本フィールド詳細仕様（128ビット固定）

### ビット配置図（リトルエンディアン）

```
 ビット位置: 0    8    16   24   32               64               96      128
           ┌────┬────┬────┬────┬────────────────┬────────────────┬────────┐
           │制御│パケ│タイ│フラ│   タイムスタンプ │   エリア情報    │チェック│
           │情報│ット│プ  │グ群│    (64ビット)   │   (32ビット)    │サム    │
           └────┴────┴────┴────┴────────────────┴────────────────┴────────┘
           0    8    16   24   32               64               96      128
```

### フィールド詳細仕様表

| フィールド名 | ビット位置 | ビット長 | データ型 | 値域 | 用途 |
|-------------|-----------|---------|---------|------|------|
| **制御情報ブロック** | 0-31 | 32ビット | - | - | パケット基本制御 |
| `version` | 0-3 | 4ビット | uint4 | 0-15 | プロトコルバージョン |
| `packet_id` | 4-15 | 12ビット | uint12 | 1-4095 | パケット識別子 |
| `type` | 16-18 | 3ビット | uint3 | 0-7 | パケットタイプ |
| `weather_flag` | 19 | 1ビット | bool | 0/1 | 天気情報有効フラグ |
| `temperature_flag` | 20 | 1ビット | bool | 0/1 | 気温情報有効フラグ |
| `pop_flag` | 21 | 1ビット | bool | 0/1 | 降水確率有効フラグ |
| `alert_flag` | 22 | 1ビット | bool | 0/1 | 警報情報有効フラグ |
| `disaster_flag` | 23 | 1ビット | bool | 0/1 | 災害情報有効フラグ |
| `ex_flag` | 24 | 1ビット | bool | 0/1 | **拡張フィールド有効フラグ** |
| `day` | 25-27 | 3ビット | uint3 | 0-7 | 予報日数 |
| `reserved` | 28-31 | 4ビット | uint4 | 0 | 予約領域 |
| **時間情報ブロック** | 32-95 | 64ビット | - | - | タイムスタンプ |
| `timestamp` | 32-95 | 64ビット | uint64 | - | UNIX時刻（秒） |
| **位置情報ブロック** | 96-127 | 32ビット | - | - | 地域識別・検証 |
| `area_code` | 96-115 | 20ビット | uint20 | 0-1048575 | JIS地域コード |
| `checksum` | 116-127 | 12ビット | uint12 | 0-4095 | パケット整合性検証 |

### ビット順序とエンディアン

WIPパケットは**完全リトルエンディアン**設計です：

```
ビット表現例（version=1, packet_id=123の場合）:
  MSB                                                           LSB
   ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
   │0│0│0│0│0│1│1│1│1│0│1│1│0│0│0│1│  16ビット
   └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
    15  12  8   4   0                   ビット位置
    packet_id(123)   version(1)
```

## 🔸 拡張フィールド詳細仕様

### 拡張フィールド有効条件

拡張フィールドは`ex_flag = 1`の場合のみ存在し、基本フィールドの128ビット目以降に配置されます。

### レコード構造

各拡張フィールドは1つ以上のレコードで構成され、各レコードは以下の構造を持ちます：

```
レコード構造 (可変長):
┌──────────────────┬────────────────────────────────────────┐
│   ヘッダー部分    │             データ部分                │
│    (16ビット)    │            (可変長)                   │
├──────────────────┼────────────────────────────────────────┤
│ ┌─────┬────────┐ │ ┌────────────────────────────────────┐ │
│ │キー │データ長│ │ │        実際のデータ                │ │
│ │6bit │10bit  │ │ │     (UTF-8/バイナリ)               │ │
│ └─────┴────────┘ │ └────────────────────────────────────┘ │
└──────────────────┴────────────────────────────────────────┘
  0     6      16   16                                    16+データ長
```

### ヘッダー詳細仕様

| 要素 | ビット位置 | ビット長 | 用途 | 値域 |
|------|-----------|---------|------|------|
| キー | 0-5 | 6ビット | フィールドタイプ識別 | 1-63 |
| データ長 | 6-15 | 10ビット | データ部分のバイト長 | 0-1023 |

### サポートフィールドタイプ

| フィールド名 | キー値 | データ型 | エンコード方式 | 最大サイズ | 説明 |
|-------------|--------|---------|---------------|-----------|------|
| `alert` | 1 | List[str] | UTF-8 | 1023バイト/レコード | 警報情報リスト |
| `disaster` | 2 | List[str] | UTF-8 | 1023バイト/レコード | 災害情報リスト |
| `latitude` | 33 | float | int32(×1_000_000) | 4バイト | 緯度座標 |
| `longitude` | 34 | float | int32(×1_000_000) | 4バイト | 経度座標 |
| `source` | 40 | str | UTF-8 | 1023バイト | 送信元情報 |

### データエンコード仕様

#### 1. 文字列型（UTF-8）
```python
# 例: "津波警報" → UTF-8バイト列
data = "津波警報".encode('utf-8')  # 12バイト
header = (field_key << 10) | len(data)  # キー + データ長
```

#### 2. 座標型（int32スケール）
```python
# 例: 緯度35.6895 → int32
scaled_value = int(35.6895 * 1_000_000)  # 3568950
data = scaled_value.to_bytes(4, 'little')  # 4バイトリトルエンディアン
```

#### 3. リスト型（連続レコード）
```python
# 例: ["津波警報", "大雨警報"] → 2つのレコード
for item in alert_list:
    item_data = item.encode('utf-8')
    header = (1 << 10) | len(item_data)  # alertキー=1
    record = header.to_bytes(2, 'little') + item_data
```

## 📐 パケットサイズ計算

### 基本パケットサイズ
```
基本フィールド = 128ビット = 16バイト（固定）
```

### 拡張フィールドサイズ
```
拡張フィールドサイズ = Σ(レコードサイズ)
レコードサイズ = ヘッダー(2バイト) + データサイズ(可変)
```

### 実例計算

#### 例1: 警報パケット
```python
ex_field = {'alert': ["津波警報", "大雨警報"]}

# レコード1: "津波警報"
data1 = "津波警報".encode('utf-8')  # 12バイト
record1 = 2 + 12 = 14バイト

# レコード2: "大雨警報"  
data2 = "大雨警報".encode('utf-8')  # 12バイト
record2 = 2 + 12 = 14バイト

# 総サイズ
total = 16 + 14 + 14 = 44バイト
```

#### 例2: 座標パケット
```python
ex_field = {'latitude': 35.6895, 'longitude': 139.6917}

# latitudeレコード: 4バイトデータ
lat_record = 2 + 4 = 6バイト

# longitudeレコード: 4バイトデータ
lon_record = 2 + 4 = 6バイト

# 総サイズ
total = 16 + 6 + 6 = 28バイト
```

## 🔧 実装仕様

### ビット操作関数

#### extract_bits関数
```python
def extract_bits(data: int, position: int, length: int) -> int:
    """
    リトルエンディアンでビットを抽出
    
    Args:
        data: 元データ
        position: 開始ビット位置（LSBから）
        length: 抽出ビット長
    
    Returns:
        抽出されたビット値
    """
    mask = (1 << length) - 1
    return (data >> position) & mask
```

#### set_bits関数
```python
def set_bits(data: int, position: int, length: int, value: int) -> int:
    """
    リトルエンディアンでビットを設定
    
    Args:
        data: 元データ
        position: 開始ビット位置（LSBから）
        length: 設定ビット長
        value: 設定値
    
    Returns:
        ビット設定後のデータ
    """
    mask = (1 << length) - 1
    cleared = data & ~(mask << position)
    return cleared | ((value & mask) << position)
```

### パケット変換フロー

#### 送信側
```
1. フィールド値設定
   ↓
2. 基本フィールドビット化
   ↓
3. 拡張フィールドエンコード
   ↓
4. ビット列結合
   ↓
5. バイト列変換
   ↓
6. 送信
```

#### 受信側
```
1. バイト列受信
   ↓
2. ビット列変換
   ↓
3. 基本フィールド抽出
   ↓
4. 拡張フィールドデコード
   ↓
5. パケットオブジェクト復元
```

## 📊 パフォーマンス特性

### ビット効率性

| フィールドタイプ | 理論最小サイズ | 実装サイズ | オーバーヘッド |
|-----------------|---------------|-----------|---------------|
| 基本パケット | 14バイト | 16バイト | 2バイト (12.5%) |
| 警報1件 | +3バイト | +14バイト | +11バイト |
| 座標情報 | +8バイト | +12バイト | +4バイト |

### 処理速度

- **ビット操作**: O(1) - 高速ビットシフト演算
- **エンコード**: O(n) - データサイズに比例
- **デコード**: O(n) - データサイズに比例

## 🧪 検証とテスト

### チェックサム計算
```python
def calculate_checksum(packet_data: bytes) -> int:
    """
    パケットのチェックサムを計算
    基本フィールドの最初116ビットを対象
    """
    checksum = 0
    for byte in packet_data[:14]:  # 116ビット = 14.5バイト ≈ 14バイト
        checksum ^= byte
    return checksum & 0xFFF  # 12ビットマスク
```

### パケット検証
```python
def verify_packet(packet: Format) -> bool:
    """パケットの整合性を検証"""
    # 1. バージョンチェック
    if packet.version != 1:
        return False
    
    # 2. パケットIDチェック
    if not (1 <= packet.packet_id <= 4095):
        return False
    
    # 3. タイムスタンプチェック
    if packet.timestamp <= 0:
        return False
    
    # 4. チェックサム検証
    calculated = calculate_checksum(packet.to_bytes())
    return calculated == packet.checksum
```

## 🔄 バージョン互換性

### 後方互換性戦略

1. **基本フィールド**: 構造変更不可（互換性保証）
2. **拡張フィールド**: 新しいキー値で機能追加
3. **バージョン管理**: versionフィールドで識別

### マイグレーション指針

```python
def migrate_packet(old_packet: bytes, target_version: int) -> bytes:
    """旧バージョンパケットの新バージョンへの変換"""
    packet = Format.from_bytes(old_packet)
    
    if packet.version < target_version:
        # バージョンアップ処理
        packet.version = target_version
        # 必要に応じて新フィールド追加
    
    return packet.to_bytes()
```

## 📋 実装ガイドライン

### 1. 新フィールド追加
```python
# 新しい拡張フィールドタイプの追加例
FIELD_MAPPING_STR = {
    'alert': 1,
    'disaster': 2,
    'latitude': 33,
    'longitude': 34,
    'source': 40,
    'new_field': 41,  # 新しいフィールド
}
```

### 2. エラーハンドリング
```python
try:
    packet = Format.from_bytes(data)
except PacketDecodeError as e:
    # パケット解析エラー処理
    logger.error(f"パケット解析失敗: {e}")
except ChecksumMismatchError as e:
    # チェックサム不一致エラー処理
    logger.error(f"チェックサム不一致: {e}")
```


## 📚 参考資料

- RFC 1042: Standard for the transmission of IP datagrams over IEEE 802 networks
- IEEE 802.3: Ethernet specification
- JIS X 0208: 日本語文字コード体系
- WIP Protocol Specification v1.0

---

この仕様書は WIP v1.0 に基づいて作成されています。
仕様変更や追加機能については、バージョン管理に従って更新されます。
